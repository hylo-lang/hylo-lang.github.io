---
title: Add Neovim Support for Your Language
description: Learn how to use Neovim's Mason package manager and built-in LSP client to set up language server support for your language.
date: 2025-12-14
author: Ambrus TÃ³th
---
import {Aside} from '@astrojs/starlight/components';

When we are building a new programming language, one of the most rewarding steps is to add support for our favorite
editor (Neovim). This can be implemented as just syntax highlighting (requiring a grammar definition),
or a language server implementation that can be later extended to provide several capabilities, including
semantic syntax highlighting, code completion, refactoring tools and more.

## Syntax Highlighting
Neovim has 2 well-established modern ways of adding syntax highlighting for languages (as of 2025): by writing a
[tree-sitter](https://tree-sitter.github.io/tree-sitter/index.html) grammar, or by leveraging our compiler through the
language server protocol. Making a tree-sitter grammar unlocks super fast, incremental parsing, and a rich set of Neovim
functionality involving the syntax tree and [text objects](https://ofirgall.github.io/learn-nvim/chapters/05-text-objects.html#treesitter-text-objects).
On the other hand, using the language server protocol allows us to use our existing compiler frontend, thus guaranteeing
100% highlighting accuracy.

When I started using Neovim, Hylo already had a [syntax specification](https://hylo-lang.org/docs/reference/specification/), a native parser in the compiler, and a TextMate
grammar for our [VSCode extension](https://github.com/hylo-lang/vscode-hylo). As it usually goes with
redundant information, these 3 grammars went out of sync over time, partly because different people were maintaining them
without clear links connecting them, and partly because we always have more fun/pressing things to work on
than synchronizing grammars.

In the long run, we could phrase the language specification in a formal grammar language, deriving other grammars
from it, or add [property based tests](https://www.youtube.com/watch?v=zvRAyq5wj38) that run the grammars through different
(randomly generated) sample programs, checking that they all parse consistently. This has its own challenges, and it's likely a fun rabbit hole that we shall
resist going down *for now ;)*

There are some interesting projects, namely [scorpeon.vim](https://github.com/uga-rosa/scorpeon.vim) and
[nvim-textmate](https://github.com/icedman/nvim-textmate) that aim to bring TextMate grammar support to Neovim through
NodeJS interop, which would allow us to reuse our grammar from VSCode. Unfortunately, this has some performance
overhead and additional installation complexity, so we chose to integrate the remaining option:
[Hylo's language server](https://github.com/hylo-lang/hylo-language-server).

## Creating a Language Server
To get the accelerated benefit of building a language server, Microsoft standardized the Language Server Protocol (LSP),
allowing us to write all language-specific logic in the server, and configure thin clients in
different editors for setting up the communication. Language servers run in separate processes and communicate with the
editor via JSON messages through stdio, pipes, or in whatever other crazy way we want (in which case we would likely
need to implement custom support on the editor side).

import {Image} from "astro:assets";
import lspArchitecture from './lsp-architecture.png';

<Image src={lspArchitecture} width="800" alt="Architecture of the Language Server Protocol"/>

Because of this decoupling, we can implement our server in virtually any [civilized programming
language](https://microsoft.github.io/language-server-protocol/implementors/sdks/) using a library that lets us handle
the client's requests and send back responses. It's the best if we can use the same language as our compiler, as we
can reuse parts of the compiler codebase as a library for different queries, like getting the list of symbols,
or reporting diagnostics from the frontend.

## Publishing Your Language Server
You can skip this step if you are just getting started, but the most convenient way to distribute our language server
is through setting up a release process on GitHub. This process, at minimum should consist of the following steps:
- Build our language server (for each supported platform if needed, e.g. Windows/Linux/macOS, x64/arm64)
- Run our tests so we don't accidentally publish a broken version
- Create a GitHub Release with the built binaries as (zipped) assets, with predictable names (e.g. `hylo-language-server-v1.2.3-linux-x64.zip`)

We can configure GitHub Actions to run the above steps whenever we push a new tag. See Hylo's
[release workflow](https://github.com/hylo-lang/hylo-language-server/blob/68657d5e7109f7c78d992a518655132343a7a52e/.github/workflows/publish-release-version.yml) as an example.

<Aside type="tip">
    If our language server relies on some assets other than the binary itself (e.g. the standard library sources), it's
    the most straightforward to bundle them all into a single release archive, and resolve them automatically with a
    relative path from the binary location when needed. This will simplify the download and extraction logic for all LSP
    clients we want to add and maintain support for.
    Nonetheless, we can always make things more complicated if our assets are very large, and we wanted to avoid
    bundling them into every platform's release archive.
</Aside>

## Language Server Integration
Now that our binary is accessible via GitHub Releases, we need to teach Neovim how to find and launch it.

There have been several implementations of language clients for Neovim ([LanguageClient-neovim](https://github.com/autozimu/LanguageClient-neovim), [coc.nvim](https://github.com/neoclide/coc.nvim), [vim-lsc](https://github.com/natebosch/vim-lsc), [ALE](https://github.com/dense-analysis/ale), just to mention a few). To address the demand, [Neovim 0.5](https://neovim.io/roadmap/#:~:text=Updated%20defaults-,0.5%20%2B%200.5.1,-Expanded%20Lua%20API) introduced a built-in LSP client, which exposed low-level primitives, and largely streamlined the integration process: when introducing a new language, we only need to take care of downloading and starting the language server executable.

The Neovim core team maintains the [nvim-lspconfig](https://github.com/neovim/nvim-lspconfig/) repository, which is responsible for configurations about starting the language server. We can fork this repository and add a new configuration for our language by looking at the existing configurations and the [contributing guide](https://github.com/neovim/nvim-lspconfig/?tab=contributing-ov-file). Hylo's configuration is as simple as [this](https://github.com/neovim/nvim-lspconfig/blob/master/lsp/hylo_ls.lua):

```lua title=lsp/hylo_ls.lua
---@type vim.lsp.Config
return {
  cmd = { 'hylo-language-server', '--stdio' },
  filetypes = { 'hylo' },
  root_markers = { '.git' },
  settings = {},
}
```

If you have the language server available on your PATH, you can test this with the following Neovim configuration:
```lua title=init.lua ins={19-23, 26-35} "/path/to/nvim-lspconfig/"
-- Bootstrap lazy.nvim
local lazypath = vim.fn.stdpath("data") .. "/lazy/lazy.nvim"
if not (vim.uv or vim.loop).fs_stat(lazypath) then
    local lazyrepo = "https://github.com/folke/lazy.nvim.git"
    local out = vim.fn.system({ "git", "clone", "--filter=blob:none", "--branch=stable", lazyrepo, lazypath })
    if vim.v.shell_error ~= 0 then
        vim.api.nvim_echo({
            { "Failed to clone lazy.nvim:\n", "ErrorMsg" },
            { out,                            "WarningMsg" },
            { "\nPress any key to exit..." },
        }, true, {})
        vim.fn.getchar()
        os.exit(1)
    end
end
vim.opt.rtp:prepend(lazypath)

-- Add filetype detection for our language
vim.filetype.add({
    extension = {
        hylo = "hylo", -- matches `filetypes` in lsp/hylo_ls.lua
    },
})

require("lazy").setup({
    {
        "neovim/nvim-lspconfig",
        -- Use a local override during development:
        dir = "/path/to/nvim-lspconfig/",

        config = function()
            -- Start the LSP for our language
            vim.lsp.enable("hylo_ls") -- matches the file name of lsp/hylo_ls.lua
        end
    }
})
```

This should already be enough to get started. In fact, this is the ideal setup for developing your language server, you just need to make sure to add your built binary to the PATH before starting Neovim. You can verify that the language server is running by editing a `.hylo` file and checking the output of `:LspInfo`

![LSP Info showing that hylo_ls is active for 1 buffer](./lspinfo.png)

## Installing the language server through Mason
While the above setup is great for development, it is more complicated for our end users than it needs to be. Luckily, Neovim has a great package manager for language servers, debug adapters and code formatters called **Mason**. To add our language server to Mason, we need to fork the [mason-registry](https://github.com/mason-org/mason-registry/) and add a package according to their [contributing guide](https://github.com/mason-org/mason-registry/blob/main/CONTRIBUTING.md). It can be as simple as downloading a NodeJS package, but you can also specify different archives for different platforms, containing pre-built binaries like in [Hylo's package.yaml](https://github.com/mason-org/mason-registry/blob/main/packages/hylo-language-server/package.yaml). If you have a more complex installation process, you can also write [installation scripts](https://github.com/mason-org/mason-registry/blob/main/CONTRIBUTING.md#github-build-from-source) per platform.

During the development of our Mason registry fork, we can add the alternative local registry as follows:

```lua title=init.lua ins={8-11} del={13} ins={15-30} "/path/to/mason-registry/" "/path/to/nvim-lspconfig/"
...
require("lazy").setup({
    {
        "neovim/nvim-lspconfig",
        -- Use a local override during development:
        dir = "/path/to/nvim-lspconfig/",

        dependencies = {
            "williamboman/mason.nvim",
            "williamboman/mason-lspconfig.nvim",
        },
        config = function()
            vim.lsp.enable("hylo_ls")

            -- Set up Mason
            require("mason").setup {
                -- Use a local registry override during development:
                registries = {
                    "file:/path/to/mason-registry/"
                }
            }

            -- Ensure our language server is installed and started automatically
            require("mason-lspconfig").setup({
                ensure_installed = {
                    "hylo_ls" -- matches the file name of lsp/hylo_ls.lua
                },
                automatic_enable = true
            })
        end
    }
})
```

After changing version of dependencies, we may need to run this command to update them:
```neovim
:Lazy sync
```

import LazySyncImage from './lazysync.png';

<Image src={LazySyncImage} width="800" alt="Lazy sync installing latest versions of dependencies"/>

We should be able to see our language server being shown in the Mason window:
```neovim
:Mason
```

import MasonImage from './mason.png';

<Image src={MasonImage} width="800" alt="Mason popup showing that hylo-language-server and lua-language-server are installed."/>


## Conclusion and next steps
We have set up Neovim support for our language. If everything goes well and your language gets accepted into nvm-lspconfig and mason-registry, your users will just need to add the language as any other language server through Mason. Otherwise, you can ask your users to add your mason-registry fork as a registry source.

Eventually, we will need to write a tree-sitter grammar, so that more Neovim functionality can be unlocked, and to ensure proper highlighting even before our language server has started up (or perish the thought, after it crashed). Until then, get coding, and have some fun!
